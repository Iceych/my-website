import{d as t,o as s,c as l,f as p,g as d,w as i,b as n,h as r,i as m}from"./index-9362ae99.js";const u={class:"markdown-body"},h=t({__name:"工作流规范",setup(o,{expose:c}){return c({frontmatter:{},excerpt:void 0}),(a,e)=>(s(),l("div",u,e[0]||(e[0]=[p(`<h1 id="%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%A7%84%E8%8C%83" tabindex="-1">工作流规范</h1><h2 id="%E4%B8%80%E3%80%81%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E8%8C%83" tabindex="-1">一、版本号规范</h2><p>采用Semver(语义化版本号)</p><h3 id="%E7%89%88%E6%9C%AC%E6%A0%BC%E5%BC%8F" tabindex="-1">版本格式</h3><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><ul><li>主版本号(major)：当你做了不兼容的 API 修改，</li><li>次版本号(minor)：当你做了向下兼容的功能性新增，可以理解为Feature版本，</li><li>修订号(patch)：当你做了向下兼容的问题修正，可以理解为Bug fix版本</li></ul><p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><h3 id="%E5%85%88%E8%A1%8C%E7%89%88%E6%9C%AC" tabindex="-1">先行版本</h3><p>当要发布大版本或者核心的Feature时，但是又不能保证这个版本的功能 100% 正常。这个时候就需要通过发布先行版本。比较常见的先行版本包括：内测版、灰度版本了和RC版本。Semver规范中使用alpha、beta、rc(以前叫做gama)来修饰即将要发布的版本。它们的含义是：</p><ul><li>alpha: 内部版本（开发版本）</li><li>beta: 公测版本（待上线版本）</li><li>rc: 即Release candiate，正式版本的候选版本（线上版本）</li></ul><p>比如：1.0.0-alpha.0, 1.0.0-alpha.1, 1.0.0-beta.0, 1.0.0-rc.0, 1.0.p-rc.1 等版本。alpha, beta, rc后需要带上次数信息。</p><h3 id="%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83%E5%87%86%E5%88%99" tabindex="-1">版本发布准则</h3><p>列举出比较实用的一些规则：</p><ul><li>标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零，版本发布需要严格递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</li><li>某个版本上线后，任何修改都必须以新版本上线。</li><li><code class="">1.0.0</code> 的版本号用于界定公共 API。当你的项目发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。</li><li>版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。</li></ul><h2 id="%E4%BA%8C%E3%80%81git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83" tabindex="-1">二、git提交规范</h2><p>团队使用 <a href="https://github.com/commitizen/cz-cli">commitizen</a> 结合 <a href="https://github.com/conventional-changelog/commitlint">commitlint</a> 作为规范提交信息统一工具。项目不能直接使用 <code class="">git commit</code> ，改为使用<code class="">git cz</code>。统一框架项目中可执行 <code class="">npm run commit</code> 提交信息。</p><h3 id="%E8%A7%84%E8%8C%83%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E" tabindex="-1">规范格式说明</h3><p>生成的提交信息格式为</p><p><code class="">&lt;commit-type&gt;[(commit-scope)]: &lt;commit-message&gt;</code></p><p>说明具体：</p><ul><li>commit-type 类型： <ul><li>build：主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交</li><li>ci：主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交</li><li>docs：文档更新</li><li>feat：新增功能</li><li>fix：bug 修复</li><li>perf：性能优化</li><li>refactor：重构代码(既没有新增功能，也没有修复 bug)</li><li>style：不影响程序逻辑的代码修改(修改空白字符，补全缺失的分号等)</li><li>test：新增测试用例或是更新现有测试</li><li>revert：回滚某个更早之前的提交</li><li>chore：不属于以上类型的其他类型</li></ul></li><li>commit-scope 可选，表示范围，例如：refactor(cli)，表示关于 cli 部分的代码重构。</li><li>commit-message 提交记录的信息。</li></ul><h2 id="%E4%B8%89%E3%80%81%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%A7%84%E8%8C%83" tabindex="-1">三、版本控制系统规范</h2><p>git进行版本管理会让分支和合并更加容易。git允许更多样的分支策略和工作流.</p><h3 id="%E4%B8%BB%E6%B5%81flow" tabindex="-1">主流flow</h3><p>首先要把文件从文件拷贝添加到缓存区中，之后再把他们提交到本地库中，最后把他们推送到远程的共享仓库中。</p><p>工作流目前主流的有三种：</p><ul><li>git flow</li><li>github flow</li><li>gitlab flow</li></ul><h4 id="git-flow" tabindex="-1">git flow</h4><p>它的特点是长期存在两个分支：</p><ul><li>主分支：master</li><li>开发分支: develop</li></ul><p>前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；而开发分支用于日常开发，存放最新的开发版。另外项目也会存在几种短期的分支：</p><ul><li>功能分支 feature</li><li>补丁分支 hotfix</li><li>预发分支 release branch</li></ul><p>这几个分支完成开发，被合并进去<code class="">develop</code>或<code class="">master</code>后，就会被删除。</p><p>这个工作流的缺点是相对复杂，需要同时维护两个长期分支，大多数工具是将<code class="">master</code>作为默认分支，可开发是在<code class="">develop</code>开发，经常需要切换。</p><h4 id="github-flow" tabindex="-1">github flow</h4><p>长期只有一个分支：<code class="">master</code>分支。当需要讨论的时候，需要向<code class="">master</code> 发起一个<code class="">pull request</code>， 这个<code class="">pull request</code>既是一个通知，又是一种对话机制，大家一起评审和讨论你的代码。</p><p><em>这个工作流程的优点就是只有一个分支，缺点就是：只有一个分支不够用，<code class="">master</code>分支的最新代码，默认就是当前的线上代码。</em></p><h4 id="gitlab-flow" tabindex="-1">gitlab flow</h4><p>这是<code class="">gitlab.com</code>推荐的做法。</p><p><code class="">gitlab flow</code>的特点就是：上游优先(<code class="">upstream first</code>), 即只存在一个主分支<code class="">master</code>， 它是所有其他分支的上游, 只有上游分支采纳的代码变化，才能应用到其他分支。</p><h4 id="%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83" tabindex="-1">版本发布</h4><p>对于版本发布的项目，建议的做法是每一个稳定版本，都要从<code class="">master</code>分支拉出一个分支，比如<code class="">1.0.0</code> 等。</p><p>以后，只有修复<code class="">bug</code>, 先合并到上游分支, 然后可以通过<code class="">cherry-pick</code>合到发布分支上，这样就可以保证发布分支上的<code class="">bug</code>， 主分支上一定是被修复的。</p><p>使用<code class="">gitlab</code>建立<code class="">group project</code>，可以将成员全部添加进小组中，每个人的提交都以分支合并进<code class="">master</code>分支的方式进行，我们可以将<code class="">master</code>设置成<code class="">protected branch</code>，这样就做到了强制代码<code class="">review</code>的机制，利于提升代码的质量。</p><h3 id="gitlab-flow-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" tabindex="-1">gitlab-flow 工作流程</h3><h4 id="fork" tabindex="-1">fork</h4><p><code class="">fork</code> 是将服务端的代码仓库克隆出一个自己的远程仓库，这样就有了一个可以自由提交的远程仓库，然后可以通过提交merge request，把自己的提交贡献回给原仓库。</p><p><code class="">fork</code>完之后回到首页，就可以看到有两个仓库：</p><h4 id="clone" tabindex="-1">clone</h4><p>把自己的远程仓库的代码clone 到本地。</p><h4 id="remote-add-upstream-%E6%B7%BB%E5%8A%A0%E4%B8%8A%E6%B8%B8%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%E3%80%82" tabindex="-1">remote add upstream 添加上游仓库地址。</h4><p><code class="">git remote add upstream http://xx.xx.xx.xx/xx.git</code> 这里的upstream就是上游服务器仓库地址的别名。</p><p>创建成功之后，可以通过命令：git remote -v 来查看远程的仓库：</p><h4 id="%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93" tabindex="-1">更新本地仓库</h4><p>当上游的远程仓库有了更新(别人进行了若干提交), 你需要将这个更新取回到本地，并在本地的master分支上合并远程分支。 <code class="">git fetch upstream</code><code class="">git merge upstream/master</code></p><p>如果你这个时候在某个发布分支上：<code class="">1.0.0</code>, 那么你需要将上游的<code class="">1.0.0</code>分支合并到自己本地的<code class="">1.0.0</code>, 而不是<code class="">master</code>分支了。<code class="">git merge upstream/1.0.0</code></p><p>当然这两个命令，也可以合并到<code class="">git pull</code>命令执行。</p><h4 id="%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81" tabindex="-1">提交代码</h4><p>当你完成了一项功能或修复了一些bug之后，需要将代码提交到本地仓库， 并推送到远程主机。</p><p><code class="">git commit -m &quot;fix som bug&quot;</code></p><p><code class="">git push origin master</code></p><h4 id="merge-request" tabindex="-1">merge request</h4><p>由于master分支是默认受保护的分支，并不是所有的人都有权限将代码推送到远程主机，所以需要提交一个<code class="">merge request(MR)</code>。 进入自己仓库地址，新建一个<code class="">MR</code></p><p>点击<code class="">new merge request</code></p><p>点击<code class="">compare branches and continue</code></p><p>当某人看到这个<code class="">review</code>请求后，可以帮忙<code class="">review</code>代码，如果代码出现不规范的地方，可以对相应的代码处进行说明：</p><p>当管理员看到提交已经被<code class="">review</code>之后，就可以<code class="">merge</code>到上游仓库了。</p><h3 id="checkout-%E6%96%B0%E5%88%86%E6%94%AF" tabindex="-1">checkout 新分支</h3><p>当一个需求的开发进入到了预发布的状态时，需要拉一个发布分支出来，比如<code class="">5.8.0</code>. 然后本地利用<code class="">checkout -b </code>在本地新建一个分支<code class="">5.8.0</code>。 <code class="">-b</code>的意思是如果不存在，会新建分支。 如果<code class="">5.8.0</code>已经存在的话，那么就不需要添加参数<code class="">-b</code>了。</p><p>演示：</p><p><code class="">git fetch upstream</code></p><p><code class="">git checkout -b 5.8.0 origin/5.8.0</code></p><p>如果有提交，\bpush的时候，命令为：</p><p><code class="">git push origin</code></p><p>此时比如说有一个bug，已经在<code class="">master</code>分支上修复且提交了，那如何合到<code class="">5.8.0</code>呢？需要用命令<code class="">cherry-pick</code> 到5.8.0.</p><p>比如master此时有一个提交，<code class="">commit id</code> 为 <code class="">0aeac80b7452113c860928de90b2ba227bef1651</code> (可通过命令行：<code class="">git log</code>来查看提交记录)</p><p>只需要切换到<code class="">5.8.0</code> 分支，然后<code class="">cherry-pick xxx</code>，即可。</p><p>又或者管理员在<code class="">upstream</code> 上游仓库中找到相应的提交，统一做<code class="">cherry-pick</code>。</p><h3 id="%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3" tabindex="-1">冲突解决</h3><p>如果对同一个文件，<code class="">A</code> 进行了修改，你也进行了修改，然后<code class="">A</code>提交，你也提交了，由于<code class="">A</code>的提交没有合到<code class="">upstream</code>,所以你的提交也就不会产生冲突，但是当管理员先将<code class="">A</code>合入到远程仓库(<code class="">upstream</code>)时，你的提交就会产生冲突了，此时你需要重新更新，解决冲突后，再提交。</p><p>具体命令为： <code class="">git fetch upstream</code></p><p><code class="">git merge upstream/master</code></p><p>如果此时<code class="">merge</code>失败，说明文件有冲突；</p><p><code class="">git stash</code></p><p><code class="">git merge upstream/master</code></p><p><code class="">git stash pop</code></p><p><code class="">pop</code>之后，会有一些文件出现冲突，此时可进相应冲突文件，进行手动解决冲突。解决完冲突之后，就可以重新<code class="">add</code> 和 <code class="">commit</code> 了。</p><p><code class="">git add .</code>（<code class="">git add .</code> 中的<code class="">.</code>是添加当前所有文件）</p><p><code class="">git commit -m &quot;fix conflict&quot;</code></p><h3 id="%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE" tabindex="-1">常见配置</h3><pre class="language-bash"><code class="language-bash"><span class="token punctuation">[</span>user<span class="token punctuation">]</span>
        name <span class="token operator">=</span> taohuahua
        email <span class="token operator">=</span> <span class="token number">819974411</span>@qq.com

<span class="token punctuation">[</span>alias<span class="token punctuation">]</span>
        co <span class="token operator">=</span> checkout
        st <span class="token operator">=</span> status
        cmt <span class="token operator">=</span> commit
        <span class="token function">ps</span> <span class="token operator">=</span> push origin master
        ci <span class="token operator">=</span> commit
        br <span class="token operator">=</span> branch
        unstage <span class="token operator">=</span> reset HEAD --
        last <span class="token operator">=</span> log <span class="token parameter variable">-1</span> HEAD
        ftc <span class="token operator">=</span> fetch upstream
        mrg <span class="token operator">=</span> merge upstream/master
<span class="token punctuation">[</span>color<span class="token punctuation">]</span>
        status <span class="token operator">=</span> auto
        <span class="token function">diff</span> <span class="token operator">=</span> auto
        branch <span class="token operator">=</span> auto
        interactive <span class="token operator">=</span> auto
</code></pre>`,91)])))}}),g={__name:"workflow",setup(o){return(c,a)=>{const e=m;return s(),d(e,null,{default:i(()=>[n(r(h),{id:"markdown"})]),_:1})}}};export{g as default};
